=head1 Krang Permissions System

Krang implements an authentication and authorization system which
controls the users' ability to access different aspects of the
system.  This system works by affiliating named "groups" with sets of
privileges.  Users are then affiliated with these groups, through
which they are granted authority.

The purpose of this document is three-fold:

=over 4

=item 1. Functionality

To describe the functionality of the Krang permissions system.


=item 2. Implementation

To describe how the Krang permissions system is implemented, and why.


=item 3. Usage

To describe how to use the Krang permissions system when developing
Krang applications.


=back



=head1 Functionality

Krang's security is based on "groups".  Groups are logical containers
which are affiliated with permission settings and users.  Permissions
for a group are assigned in three major "security realms":


=head2 Security Realms

=over 4

=item 1. Sites/Categories

Sites, and the categories (e.g., directories) within each site.


=item 2. Application Classes

Includes four classes of applications: Story, Media, Templates, and Admin.


=item 3. Desks

Logical desks, such as "Edit" or "Publish"


=back



=head2 Security Levels

Within these three security realms, authority is granted to one of
three levels:


=over 4

=item A. Edit

User may add, modify or delete.


=item B. Read-Only

User can view items but not make changes.


=item C. Hide

User may neither see nor change items.


=back



=head2 Global Permissions

In addition to the realms and levels described above, there are two
security items affiliated with a group which are global to the whole
system.

=over 4

=item * Can Create Users

Controls the ability of the user to access the edit functions of the
Admin/User application.


=item * Can Publish

Controls the ability of the user to send content to the live site.


=back



=head2 Use Cases

These permissions are applied intuitively based on their context.  For
example:

=over 4


=item *

A user is granted "Read-Only" access to a particular category.  As a
result, they can see the contents of the category and its
sub-categories, but may not add, modify or delete categories in the
affected hierarchy.  Furthermore, the user may see but not edit media
and story objects which are within the affected hierarchy.


=item *

A user is granted "Edit" access to desk "A", but "Read-Only" access to
desk "B".  as a result, they can manipulate content on desk "A", and
they may move it to desk "B" -- but once on desk "B" they cannot
make any changes.


=item *

A user is granted "Hide" access to the "Admin" application class.  As
a result, they cannot see or access any of the applications in that
class, including Users, Groups, Contributors, Sites, Categories, Jobs,



=item *

A user is granted "Edit" access to "Story" and "Media" application
classes, but not to "Templates".  As a result, they can manage
content, but may not make changes to the templates which control the
appearance of content.

=back



=head1 Implementation

There are two primary tasks for which the Krang permissions system is
responsible:


=over 4

=item 1. API security

Limit access to Krang objects.


=item 2. UI security

Influence UI based on access to functionality.


=back


It is through these two mechanisms that Krang permissions are implemented.


=head2 API security

The purpose of API security is to limit access to Krang objects.  This
mechanism is implemented by modifying the Krang object modules (e.g.,
Krang::Media, Krang::Story, etc.).

Typically, this means modifying the find() method to hide objects
which the current user is not allowed to see and throwing exceptions
when the user tries to perform an operation they are not allowed to
perform, such as calling save() on an object to which they have
"Read-Only" access.

The implementation varies according to the security realm:

=over 4


=item * Sites/Categories

Site/categories are the most complex aspect of the Krang
permissions system.  Because categories touch so many different parts
of the Krang system, and because they are so voluminous (possibly
numbering around 10,000 per Krang instance) a special mechanism has
been devised to handle category-based permissions.

Primarily, a table called "category_group_permission" has been
created.  This table stores the category permission configuration
designated by the users.  For example, imagine the following was
configured for the "Car Editors" group:

  site1.com/, "Read-Only"
  site1.com/departments/cars/, "Edit"

The intention of the user who configured these permissions would be to
grant "Car Editors" the ability to manage content within their
section, but not anywhere else.  For example, if they wanted to add a
story to the system they would be granted access as follows to the
following categories:

  Not allowed:  site1.com/
  Allowed:      site1.com/departments/cars/
  Allowed:      site1.com/departments/cars/toyota/prius/
  Not allowed:  site1.com/departments/unicycles/

In order to make a permissions decision about the category
"site1.com/departments/cars/" there is an exact match in the
"category_group_permission" table.  Unfortunately, in order to find
permissions for "site1.com/departments/cars/toyota/prius/" it is
necessary to ascend the hierarchy until we get to
"site1.com/departments/cars/".

The "category_group_permission" table is expected to be a very sparse
matrix of categories and groups.  If we were to rely on this table for
making all category permission decisions we would spend a considerable
amount of time negotiating the category hierarchy, and performance
would greatly suffer as a result.

In order to avoid this problem, another table called
"category_group_permission_cache" has been created.  Unlike
"category_group_permission", this table stores every possible
combination of group and category.  As a result, any look up for
category/group permissions is certain to be resolved in a single
query.

Furthermore, in order to streamline the ability to integrate category
permission checking into SQL, the permission levels "Edit",
"Read-Only", and "Hide" have been implemented as two columns in
"category_group_permission_cache": "may_see" and "may_edit".

Finally, it is important to recognize that a user may be a member of
more than one group.  The result of this is that the database may
return more than one row per user/category.  In order to compensate
for the possible 1:N nature of users to qualifying groups, a group-by
SQL mechanism should be employeed when retrieving permissions, and a
"select distinct" when doing a count.

Put together with the rest of the system, here is how a count of media
records might be implemented in SQL:

  select
    count(distinct media_id)

  from
    media
      left join category_group_permission_cache as cgpc
        ON cgpc.category_id = media.category_id
      left join usr_user_group
        ON cgpc.group_id = usr_user_group.user_group_id

  where
    usr_user_group.user_id = 1 AND
    cgpc.may_see = 1 


Here is how you would retrieve matching media records for the same
query.  Note the use of sum() and "group by":

  select
    media.media_id,
    media.title,
    media.category_id,
    (sum(cgpc.may_edit) > 0) as may_edit,
    (sum(cgpc.may_edit) > 0) as may_edit

  from
    media
      left join category_group_permission_cache as cgpc
        ON cgpc.category_id = media.category_id
      left join usr_user_group
        ON cgpc.group_id = usr_user_group.user_group_id

  where
    usr_user_group.user_id = 1 AND
    cgpc.may_see = 1 

  group by
    media.media_id

Because may_see and may_edit columns will contain "1" if true and "0"
if not, sum() will effectively be greater than zero if the user is
allowed to see or edit, respectively.

Maintenance of this table is managed by the Krang::Group module which
is called when categories or groups are changed.


=item * Application Classes



=item * Desks



=item * Global Permissions



=back


=head2 UI security

The purpose of UI security is to inform the various user interface
applications so that features to which the user does not have access
are hidden from view.  The goal of hiding these inaccessible features
is to improve ease of use for the typical user.

The UI security is expected to be back-stopped by the API security.
There are two reasons for this dual implementation:  First is defense
in depth.  Unauthorized actions should not simply be hidden from view
-- they should be blocked from execution.  This prevents a malicious
user who has reversed engineered UI functionality from issuing
commands which should not be allowed.

The second reason is quality assurance.  Both the UI and the API
should implement the same logical authorization rules.  If the UI
allows some functionality which is not permitted, the API will catch
the error and croak().  This will offer a better opportunity to catch
flaws in the software system before they create corrupted records in
the database.


=item * Sites/Categories



=item * Application Classes



=item * Desks



=item * Global Permissions



